generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/@prisma/client"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Enums
enum IntegrationType {
  SMTP
  WHATSAPP_EVOLUTION
  WHATSAPP_BAILEYS
  SMS_TWILIO
  SMS_ZENVIA
  TELEGRAM
}

enum IntegrationStatus {
  ACTIVE
  INACTIVE
  ERROR
  PENDING
}

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
  RECEIVED
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

// Models
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  integrations     Integration[]
  messageQueues    MessageQueue[]
  apiKeys          ApiKey[]
  webhookEndpoints WebhookEndpoint[]
}

model Integration {
  id         String            @id @default(uuid())
  name       String
  type       IntegrationType
  status     IntegrationStatus @default(PENDING)
  webhookUrl String?           @unique
  webhookKey String?

  // Configurações específicas (JSON)
  config Json

  // Metadados
  metadata Json?
  lastSync DateTime?
  errorLog String?   @db.Text

  // Estatísticas
  messagesSent      Int @default(0)
  messagesReceived  Int @default(0)
  messagesDelivered Int @default(0)
  messagesFailed    Int @default(0)

  // Relacionamentos
  userId        Int
  user          User           @relation(fields: [userId], references: [id])
  messages      Message[]
  contacts      Contact[]
  messageQueues MessageQueue[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([webhookUrl])
  @@index([type, status])
  @@index([userId])
}

model Contact {
  id String @id @default(uuid())

  // Identificadores
  phoneNumber String?
  email       String?
  telegramId  String?

  // Informações
  name     String?
  avatar   String?
  metadata Json?
  tags     String? @db.Text

  // Relacionamentos
  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([phoneNumber, integrationId])
  @@unique([email, integrationId])
  @@index([phoneNumber])
  @@index([email])
  @@index([integrationId])
}

model Message {
  id String @id @default(uuid())

  // Identificação
  externalId String?
  direction  MessageDirection
  status     MessageStatus    @default(PENDING)

  // Conteúdo
  content   String? @db.Text
  mediaUrl  String? @db.Text
  mediaType String?

  // Metadados
  metadata Json?
  headers  Json?

  // Timestamps
  sentAt      DateTime?
  deliveredAt DateTime?
  readAt      DateTime?
  failedAt    DateTime?

  // Erro
  errorMessage String? @db.Text

  // Relacionamentos
  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  fromContactId String?
  fromContact   Contact? @relation("SentMessages", fields: [fromContactId], references: [id])

  toContactId String?
  toContact   Contact? @relation("ReceivedMessages", fields: [toContactId], references: [id])

  // Thread
  threadId  String?
  replyToId String?
  replyTo   Message?  @relation("MessageReplies", fields: [replyToId], references: [id])
  replies   Message[] @relation("MessageReplies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([externalId, integrationId])
  @@index([status])
  @@index([direction])
  @@index([threadId])
  @@index([createdAt])
  @@index([integrationId])
}

model WebhookLog {
  id         String  @id @default(uuid())
  url        String
  method     String
  headers    Json
  body       Json?
  response   Json?
  statusCode Int?
  processed  Boolean @default(false)
  error      String? @db.Text

  createdAt DateTime @default(now())

  @@index([url])
  @@index([processed])
  @@index([createdAt])
}

model MessageTemplate {
  id        String          @id @default(uuid())
  name      String
  type      IntegrationType
  content   String          @db.Text
  variables Json?
  metadata  Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
}

model Setting {
  id    Int     @id @default(autoincrement())
  key   String  @unique
  value String  @db.Text
  type  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Sistema de Filas
enum QueueStatus {
  PENDING
  SCHEDULED
  PROCESSING
  SENT
  FAILED
  CANCELLED
}

enum AttemptStatus {
  PENDING
  SENT
  FAILED
}

model MessageQueue {
  id String @id @default(uuid())

  // Relacionamentos
  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  userId Int
  user   User @relation(fields: [userId], references: [id])

  // Destino
  toPhone      String?
  toEmail      String?
  toTelegramId String?
  toName       String?

  // Conteúdo
  content   String  @db.Text
  mediaUrl  String? @db.Text
  mediaType String?

  // Controle da fila
  status       QueueStatus @default(PENDING)
  priority     Int         @default(5)
  maxRetries   Int         @default(3)
  currentRetry Int         @default(0)
  minInterval  Int         @default(300) // segundos

  // Agendamento
  scheduledAt DateTime?

  // Timestamps
  lastAttemptAt DateTime?
  sentAt        DateTime?
  failedAt      DateTime?
  cancelledAt   DateTime?

  // Metadata
  metadata     Json?
  errorMessage String? @db.Text

  // Tentativas
  attempts QueueAttempt[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, scheduledAt])
  @@index([integrationId])
  @@index([userId])
  @@index([toPhone])
}

model QueueAttempt {
  id String @id @default(uuid())

  queueId String
  queue   MessageQueue @relation(fields: [queueId], references: [id], onDelete: Cascade)

  attemptNumber Int
  status        AttemptStatus @default(PENDING)

  // Resposta
  responseCode    Int?
  responseMessage String? @db.Text
  failureReason   String? @db.Text
  externalId      String?
  externalData    Json?

  // Timestamps
  startedAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([queueId])
  @@index([status])
}

// Sistema de API Keys
model ApiKey {
  id String @id @default(uuid())

  userId Int
  user   User @relation(fields: [userId], references: [id])

  name String
  key  String @unique

  // Permissões
  permissions Json // ["messages:send", "messages:read", "contacts:read"]

  // Rate Limiting
  rateLimit Int @default(60) // Requests por minuto

  // Controle
  enabled    Boolean   @default(true)
  expiresAt  DateTime?
  lastUsedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([userId])
}

// Sistema de Webhooks Outbound
model WebhookEndpoint {
  id String @id @default(uuid())

  userId Int
  user   User @relation(fields: [userId], references: [id])

  name   String
  url    String
  secret String // Para validação HMAC

  // Eventos subscritos
  events Json // ["message.sent", "message.received", "message.failed"]

  // Controle
  enabled Boolean @default(true)

  // Estatísticas
  totalSent   Int       @default(0)
  totalFailed Int       @default(0)
  lastSentAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([enabled])
}

model WebhookOutboundLog {
  id           String  @id @default(uuid())
  endpointId   String?
  event        String
  url          String
  payload      Json
  response     Json?
  statusCode   Int?
  success      Boolean
  errorMessage String? @db.Text

  createdAt DateTime @default(now())

  @@index([event])
  @@index([success])
  @@index([createdAt])
}
